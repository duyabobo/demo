# 表设计
#### 库名、表名、字段名必须使⽤⼩写字⺟，并采⽤下划线分割
#### 库名、表名、字段名禁⽌超过30个字符。须⻅名知义
#### 每张表/视图要有注释（comment），格式为：模块|用途|负责人|创建日期｜数据来源 ，例如：账号|存储账号信息|张平|2016-03-25 
#### 每个字段要有注释（comment），格式为：用途|负责人|创建日期｜数据来源 ，例如：存储用户公司ID｜张平｜2016-03-25｜t_tenant.id。
#### 如果列类型是枚举或者是枚举意义的数值类型还需要列举枚举范围并说明每个枚举值的含义，格式为：用途|负责人|创建日期｜枚举意义｜数据来源  例如：记录用户性别｜张平｜2016-03-25｜@1:男@0:女@2:未知｜#系统根据用户身份证号码判断
#### 每张表三个必加字段，id （自动增长）用作存储主键， create_time记录创建时间， update_time记录更新时间 。 这三个字段由OP维护，RD无需处理；
#### 有逻辑删除需求的表，可选增加delete_flag字段（tinyint类型，默认值为0），用来标识字段是否被逻辑删除
#### 收回RD的delete权限，所有数据不能做物理删除（逻辑上删除的需求可以通过flag标签的方式来处理）
#### 建议单个表不超过50个字段
#### 没有特殊需求，使用innodb引擎
#### 禁止在数据库中存储明文密码

# 数据库对象命名规则
#### 数据库名 小写字母组合
#### 唯一索引 uidx_{列简写}
#### 普通索引名 idx_{列简写}

# 字段类型选择
#### 所有字段均定义为NOT NULL,尽量加上默认值如deafault ''或deafault 0
#### 使用UNSIGNED存储非负数值
#### 使用INT UNSIGNED存储IPV4。用INET_ATON()、INET_NTOA()进行转换， 查询192.168网段 where ip>inet_ntoa(192.168)
#### 手机号使用BIGINT.不要用VARCHAR(11)，效率低，浪费空间
#### 状态，年龄用 TINYINT UNSIGNED，256个值，一般是足够使用的
#### INT类型固定占用4字节存储,例如INT(4)仅代表显示字符宽度为4位,不代表存储长度
#### 区分使用TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT数据类型，不要只用int和BIGINT
#### 使用TINYINT来代替ENUM类型
#### 尽量不使用TEXT、BLOB类型。当实际存储长度超过8KB（尤其是TEXT/BLOB列）的大列（large column）时会引起“page-overflow存储”，类似ORACLE中的“行迁移”。因此，如果必须使用大列（尤其是TEXT/BLOB类型）且读写频繁的话，则最好把这些列拆分到子表中，不要和主表放在一起存储。如果不太频繁，可以考虑继续保留在主表中。如果将 innodb_page_size选项修改成 8KB，那么行记录物理长度建议不超过4KB
#### 使用VARBINARY存储大小写敏感的变长字符串或二进制内容。
#### 使用尽可能小的VARCHAR字段。要给出一个合理的值，可以稍微比估算大点，但是不能大手一挥搞个1000，这样很容易让DBA想着把他搞出去。VARCHAR(N)中的N表示字符数而非字节数。如果N<256时会使用一个字节来存储长度，如果N>=256则使用两个字节来存储长度。
#### 存储年使用YEAR类型。存储日期使用DATE类型
#### 使用DATETIME存储日期时间。早前一直在传播的“常识性误导”，建议用TIMESTAMP取代DATETIME。其实从5.6开始，建议优先选择DATETIME存储日期时间，因为它的可用范围比TIMESTAMP更大，物理存储上仅比TIMESTAMP多1个字节，整体性能上的损失并不大
#### ⽤DECIMAL代替FLOAT和DOUBLE存储精确浮点数（金融行业），也可以考虑使用int或者bigint乘百倍千倍存储。
#### 使⽤VARBINARY存储⼤⼩写敏感的变⻓字符串

# 索引设计：
#### 单张表中索引数量不超过5个
#### 单个索引中的字段数不超过5个
#### 唯一键由3个以下字段组成
#### 禁止冗余索引。
#### 不在低基数列上建立索引,例如“性别”
#### 选择区分度大的列建立索引。组合索引中,区分度大的字段放在最前。
#### 对字符串使用前缀索引,前缀索引长度尽量不超过10个字符
#### 合理创建联合索引(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)
#### 合理使用覆盖索引减少IO,避免排序
#### 核⼼SQL优先考虑覆盖索引
#### 哪怕是基于索引的条件过滤，如果优化器意识到总共需要扫描的数据量超过30%时（ORACLE里貌似是20%，MySQL目前是30%，没准以后会调整），就会直接改变执行计划为全表扫描，不再使用索引。
#### 定期用 pt-duplicate-key-checker 工具检查并删除重复的索引。比如 index idx1(a, b) 索引已经涵盖了 index idx2(a)，就可以删除 idx2 索引了。

# sql写法
#### 去掉不必要的括号。
#### 使⽤in代替or，in的值不超过1000个
#### 避免在数据库中进⾏数学运算
#### 考虑⽤union all代替union，union all不去重，所以不需要对结果集再进行排序。
#### 不使⽤select * . 消耗CPU和IO、消耗⺴络带宽；无法使用索引覆盖；减少表结构带来的影响；字段过多过大select／join可能产生临时表;影响缓冲命中率。切不可偷懒！！！
#### 联表查询时,JOIN列的数据类型必须相同,并且要建立索引。
#### 有多字段联合索引时，WHERE中过滤条件的字段顺序无需和索引一致，但如果有排序、分组则就必须一致了。
#### delete,update一定要写where，哪怕是要删除所有数据。必须要有where
#### 计算放到等号的右边，否则索引实效。
#### 多表JOIN时，要把过滤性最大（不一定是数据量最小哦，而是只加了WHERE条件后过滤性最大的那个）的表选为驱动表。此外，如果JOIN之后有排序，排序字段一定要属于驱动表，才能利用驱动表上的索引完成排序。
#### SQLl中使用到OR的改写为用 IN() ，IN里面数字的个数建议控制在1000以内
#### SQL语句不可以出现隐式转换，比如 select id from 表 where id='1'
#### 使用like时，禁止讲%放在首字符位置
#### 不使⽤负向查询，如not in ，not like
#### 禁⽌使⽤order by rand() 
#### 减少与数据库的交互次数，INSERT ... ON DUPLICATE KEY UPDATE ，REPLACE INTO、INSERT IGNORE 、INSERT INTO VALUES(),(),() ，UPDATE … WHERE ID IN(10,20,50,…) 
#### UPDATE、DELETE语句需要根据WHERE条件添加索引
#### MySQL不擅长做计算，计算操作在客户端完成。
#### 有些时候查询优化器指定的索引或执行计划可能并不是最优的，可以手工指定最优索引，使用hint，force

# LIMIT方式推荐分页
#### Select * from table WHERE id>=23423 limit 11; #10+1 (每页10条)
